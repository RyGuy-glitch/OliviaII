# bot/strategies/ema_vwap_scalp.py
# Olivia’s VWAP + EMA Liquidity Scalp
# Drop-in: replace the entire contents of Nate’s file with this.
# Jitter/router/config remain exactly as they are.

from core.strategy_base import Strategy

class OliviaVWAPScalp(Strategy):
    """
    Bias filter: VWAP + EMA stack
      - Long bias:  price > vwap and ema8 > ema21 > ema50
      - Short bias: price < vwap and ema8 < ema21 < ema50

    Triggers (either side):
      1) Liquidity sweep + engulf back inside range
      2) Breakout + retest (VWAP / session H/L / OH/OL), then rejection

    Risk:
      - Micro contracts (MNQ/MES/MYM)
      - Default ~12 ticks SL if no clear swing
      - TP = 2R; runner managed by engine if desired
      - Hard daily stop handled by engine; we expose risk_management gate
    """

    def __init__(self, config):
        super().__init__(config)
        self.ema_fast = 8
        self.ema_mid  = 21
        self.ema_slow = 50
        self.use_vwap = True
        # fallback tick if none provided by data; does NOT change exchange tick
        self.default_tick = float(self._cfg_get(config, ("risk", "default_tick"), 0.25))

    # -------- public API expected by engine --------
    def should_enter_long(self, data):
        d = self._adapt(data)
        if not (d.price is not None and d.vwap is not None):
            return False
        if not (d.ema8 is not None and d.ema21 is not None and d.ema50 is not None):
            return False

        # Bias
        if not (d.price > d.vwap and d.ema8 > d.ema21 > d.ema50):
            return False

        # Triggers
        if d.liquidity_sweep_down() and d.bullish_engulfing():
            return True
        if d.breakout_retest("up"):
            return True
        return False

    def should_enter_short(self, data):
        d = self._adapt(data)
        if not (d.price is not None and d.vwap is not None):
            return False
        if not (d.ema8 is not None and d.ema21 is not None and d.ema50 is not None):
            return False

        # Bias
        if not (d.price < d.vwap and d.ema8 < d.ema21 < d.ema50):
            return False

        # Triggers
        if d.liquidity_sweep_up() and d.bearish_engulfing():
            return True
        if d.breakout_retest("down"):
            return True
        return False

    def stop_loss(self, entry, data, side):
        d = self._adapt(data)
        tick = d.tick_size or self.default_tick
        # Prefer swing/liq wick if available
        if side == "long":
            sl = d.last_swing_low
            if sl is None:
                sl = entry - (tick * 12)
            return float(sl)
        else:
            sl = d.last_swing_high
            if sl is None:
                sl = entry + (tick * 12)
            return float(sl)

    def take_profit(self, entry, data, side):
        sl = self.stop_loss(entry, data, side)
        risk = abs(entry - sl)
        if risk <= 0:
            return entry
        return float(entry + (2.0 * risk) if side == "long" else entry - (2.0 * risk))

    def risk_management(self, account):
        """
        Engine can enforce daily stops; this gate keeps behavior consistent.
        If account exposes realized_today & avg_risk, stop at -2R; otherwise allow.
        """
        rt = getattr(account, "realized_today", None)
        ar = getattr(account, "avg_risk", None)
        if rt is not None and ar is not None:
            if rt <= -2.0 * ar:
                return False
        return True

    # -------- minimal adapter (safe defaults; no engine changes needed) --------
    def _adapt(self, data):
        """Map engine fields → attributes this strategy expects. Missing pieces default safely."""
        def _fn(name, default=False):
            f = getattr(data, name, None)
            return f if callable(f) else (lambda *a, **k: default)

        return type("D", (), {
            "price": getattr(data, "price", getattr(data, "close", None)),
            "vwap": getattr(data, "vwap", getattr(data, "vwap_value", None)),
            "ema8": getattr(data, "ema8", getattr(data, "ema_8", None)),
            "ema21": getattr(data, "ema21", getattr(data, "ema_21", None)),
            "ema50": getattr(data, "ema50", getattr(data, "ema_50", None)),
            "tick_size": getattr(data, "tick_size", None),
            "last_swing_low": getattr(data, "last_swing_low", None),
            "last_swing_high": getattr(data, "last_swing_high", None),
            "liquidity_sweep_down": _fn("liquidity_sweep_down"),
            "liquidity_sweep_up":   _fn("liquidity_sweep_up"),
            "bullish_engulfing":    _fn("bullish_engulfing"),
            "bearish_engulfing":    _fn("bearish_engulfing"),
            "breakout_retest":      _fn("breakout_retest"),
        })()

    @staticmethod
    def _cfg_get(cfg, path, default=None):
        cur = cfg
        try:
            for k in path:
                cur = cur[k]
            return cur
        except Exception:
            return default


# Alias to match Nate’s expected class name if his engine imports EMAVWAPScalp
class EMAVWAPScalp(OliviaVWAPScalp):
    pass
